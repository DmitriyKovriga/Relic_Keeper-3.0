# План: система скиллов на степах (Step List)

## Цели

- Сохранить текущие ценности: пулы скиллов, привязка к предметам, «любой скилл с любым предметом».
- Перевести логику скилла на **последовательность степов** (вариант 4.2).
- Степы — полноценные сущности со своими настройками и спрайтами, но **без копирования SO**: один тип степа = один общий шаблон (дефолты), в скилле хранятся только ссылка на тип + переопределения параметров. Рантайм собирает «копию» из шаблона + оверрайдов скилла.

---

## 1. Модель данных: без дублирования степов

### 1.1 Два уровня

| Уровень | Описание | Где хранится |
|--------|----------|--------------|
| **StepDefinitionSO** (или enum + конфиг в одном SO) | Тип степа с дефолтными параметрами, иконкой, описанием для редактора. Один asset на тип («SpawnVFX», «DealDamageCircle», …). | Одна папка, например `Resources/Skills/StepDefinitions/` или один `StepDefinitionDatabaseSO` с массивом определений. |
| **StepEntry в скилле** | Ссылка на тип степа (ID или ref на StepDefinitionSO) + **только оверрайды** параметров. Опционально: **TriggerAtStepIndex** + **TriggerAtPercent** (отложенное срабатывание в момент % другого степа). Для типа **ParallelGroup** — вложенный список подстепов. | Внутри `SkillRecipeSO`: список `List<StepEntry>`. |

Рантайм при выполнении скилла:

1. Берёт очередной `StepEntry`.
2. Разрешает тип степа → получает дефолты из `StepDefinition`.
3. Сливает оверрайды из `StepEntry` поверх дефолтов → получает **StepRuntimeParams** (структура в памяти, не SO).
4. Выполняет шаг с этими параметрами.

Копий SO степов не создаётся; плодятся только данные в скилле (список записей с оверрайдами). При добавлении новых скиллов мы только добавляем ссылки на типы степов и их параметры.

### 1.2 Вариант хранения определений

- **Вариант A:** отдельный SO на каждый тип степа (`SpawnVFXStepDef.asset`, `DealDamageCircleStepDef.asset`). В скилле в `StepEntry` — ссылка на этот SO + оверрайды (поля зависят от типа, можно через один `SerializedOverride` или маленькие структуры на тип).
- **Вариант B:** один **StepDefinitionDatabaseSO** с массивом записей (StepTypeId, default params, icon, description). В скилле в `StepEntry` — StepTypeId (string или enum) + оверрайды. Меньше файлов, но один большой asset.

Рекомендация: **Вариант A** — по одному SO на тип степа. Удобно в редакторе (отдельная иконка/описание на тип), легко расширять. Папка `StepDefinitions` не захламляет проект, если имена типов понятные (`Step_SpawnVFX`, `Step_DealDamageCircle`).

---

## 2. Масштабирование по скорости атаки/каста

- В начале выполнения скилла считаем **общую длительность пайплайна**:
  - Для атак: `totalDuration = 1f / AttackSpeed` (или базовая длительность / AttackSpeed).
  - Для кастов: `totalDuration = baseCastTime / CastSpeed`.
- Каждый степ имеет **DurationPercent** (0–100% или в долях 0–1). Длительность степа в секундах:
  - `stepDuration = totalDuration * step.DurationPercent`
- Степы с DurationPercent = 0 = моментальные (один кадр): удар, спавн VFX, хитбокс, применение урона.
- Итог: цепочка степов всегда укладывается в `totalDuration`; при росте скорости атаки/каста всё сжимается пропорционально.

Отдельно: для ченнелинг-скиллов длительность «одного тика» или «одного цикла» тоже можно масштабировать от CastSpeed/AttackSpeed.

---

## 3. Додж и отмена скилла

- **Додж** — отдельная механика (отдельный слот/кнопка, свой CD).
- При активации доджа:
  - Текущий активный скилл **принудительно отменяется** (прерываем корутину/стейт-машину рантайма скилла, вызываем Cleanup/Unlock и т.д.).
  - Додж выполняется (мгновенный сдвиг или короткая анимация), ставится на кулдаун.
- Реализация: в `PlayerSkillManager` (или отдельном `DodgeController`) при вызове доджа вызывать что-то вроде `CancelCurrentSkill()` у рантайма скилла. Рантайм скилла должен уметь прерваться в любой момент (по флагу или событию) и корректно разблокировать движение, сбросить анимацию и т.д.

Додж не является степом скилла — это системный слой поверх скиллов.

---

## 4. Ченнелинг (Cyclone-стиль)

Идея: скилл работает **пока зажата кнопка**; внутри — повторяющийся цикл (тики урона, движение и т.д.).

### 4.1 Модель

- У скилла флаг **IsChanneling**.
- Пайплайн скилла делится на:
  - **Один раз при нажатии:** опциональные «начальные» степы (например, звук, стартовая анимация).
  - **Цикл пока кнопка зажата:** список степов **ChannelLoopSteps** выполняется повторно. Длительность одного цикла — либо фиксированный % от totalDuration, либо отдельный параметр (channel tick rate). После каждого цикла проверка: кнопка ещё зажата и не превышено максимальное время канала? Если да — следующий цикл; иначе выход.
  - **Один раз при отпускании:** опциональные «финальные» степы (остановка VFX, анимация выхода).

Рантайм:

- При нажатии: запуск скилла, выполнить начальные степы, перейти в состояние «channeling».
- В состоянии channeling: выполнить ChannelLoopSteps (с теми же правилами % длительности), по окончании цикла — проверка «кнопка держится?» и «не макс. время?»; если да — повторить цикл.
- При отпускании (или макс. времени): выполнить финальные степы, Cleanup, выход.

Так не нужно «скрыто вызывать скилл по новой» — один инстанс скилла крутит один цикл степов многократно, пока держится ввод.

### 4.2 Степы внутри ченнелинга

В цикл можно класть те же степы: SpawnVFX (если VFX зацикленный), DealDamage (тик урона), смещение врагов и т.д. Длительность цикла задаётся либо общим «channel tick duration» (и масштабируется от статов), либо суммой DurationPercent степов внутри цикла.

---

## 5. Каталог степов (полный список)

Ниже — объединённый список: твой черновик + текущая реализация (Cleave) + дополнения. Степы сгруппированы; для каждого указано, что хранить в определении и в оверрайдах скилла, и как увязать с длительностью пайплайна.

---

### 5.1 Степы по работе с персонажем

| # | Степ | Описание | Параметры (дефолт / оверрайд) | Длительность |
|---|------|----------|-------------------------------|--------------|
| 1 | **CharacterDisplace** | Мгновенный сдвиг (телепорт/короткий рывок). | Направление (по facing / по вводу), дистанция, можно ли сквозь стены. | 0% (моментально). |
| 2 | **CharacterLaunch** | Подбрасывание персонажа вверх (или по вектору). | Вектор/сила, время до сброса контроля (опционально). | 0% или короткий %. |
| 3 | **CharacterBuff** | Изменение стата персонажа на N времени. | StatType, значение (flat/percent), длительность в секундах (или % от пайплайна). | 0% (применение баффа), длительность баффа — отдельный параметр. |
| 4 | **MovementLock** | Временная блокировка перемещения героя. | — | 0% (момент блокировки); снимается явным степом Unlock или в Cleanup. |
| 5 | **MovementUnlock** | Снять блокировку перемещения. | — | 0%. |
| 6 | **CharacterPullDown** | Притянуть героя вниз (если в воздухе), например «приземление». | Сила/скорость притяжения, до земли или на N единиц. | 0% или короткий % пока тянет. |
| 7 | **OptionalStepForward** | Условный подшаг в сторону атаки: выполнить только если во время атаки нажата кнопка движения в сторону. | Дистанция подшага, направление (по вводу движения). | 0% или малый %. Реализация: в рантайме проверка ввода в момент степа. |

Все «моментальные» степы (0%) выполняются за один кадр; степы с длительностью — либо ждут N% от totalDuration, либо таймер в секундах (в зависимости от выбора дизайна).

---

### 5.2 Степы по оружию и анимации (под масштабирование от AttackSpeed/CastSpeed)

| # | Степ | Описание | Параметры | Длительность |
|---|------|----------|-----------|--------------|
| 8 | **WeaponWindup** | Замах оружия (рука из покоя в положение замаха). | Вариант анимации (slash / thrust / …), опционально ссылка на кривую. | N% пайплайна (например 0–35%). |
| 9 | **WeaponStrike** | Мгновенный «кадр удара» (рука в конечной точке, оружие можно скрыть). | — | 0%. |
| 10 | **WeaponRecovery** | Возврат руки в покой. | Вариант анимации. | N% пайплайна (например 35–100%). |

Длительности Windup/Recovery задаются в процентах от общей длительности скилла, чтобы при росте AttackSpeed вся анимация укорачивалась.

---

### 5.3 VFX и хитбокс/урон

| # | Степ | Описание | Параметры | Длительность | Связка VFX ↔ хитбокс |
|----|------|----------|-----------|--------------|-----------------------|
| 11 | **SpawnVFX** | Спавн одного VFX. | Prefab, offset, scale (или «от AOE стата»), attachToParent, invertFacing, flipX/Y, базовая длительность (для скорости анимации). | 0%. | — |
| 12 | **DealDamageCircle** | Хитбокс круг + нанесение урона. | Радиус, offset, damage multiplier, layer. **Опция:** «Position/Scale from step index» — взять позицию и масштаб из позиции другого степа (например предыдущего SpawnVFX). | 0%. | Если «copy from VFX step»: в оверрайдах указать индекс степа с SpawnVFX; рантайм в момент выполнения берёт последнюю позицию/скейл этого VFX (или из кэша «результат степа N»). |
| 13 | **DealDamageRectangle** | Хитбокс прямоугольник + урон. | Size (width, height), offset, rotation (или по facing), damage multiplier. Аналогично опция «from step index» для позиции/размера от VFX. | 0%. | То же. |
| 14 | **SpawnVFXAndHitbox** | Один степ: спавн VFX + в заданный момент по времени этого VFX — хитбокс и урон. | VFX params + форма хитбокса (circle/rect) + **HitboxAtPercent** (0 = в момент спавна VFX, 0.5 = середина длительности VFX, 1 = конец). Позиция/скейл хитбокса = текущие у инстанса VFX на момент срабатывания. | 0% для «запуска», длительность VFX задаётся отдельно (для анимации и момента удара). | Явно: один степ, внутри него логика «спавн VFX, по таймеру HitboxAtPercent * vfxDuration — DealDamage». Удобно для «один удар, один VFX, удар в середине анимации». |

Рекомендация по «дабл страйк» и нескольким VFX: в скилле просто **несколько степов** подряд, например: SpawnVFX (первый удар) → DealDamageCircle (from step 0) → SpawnVFX (второй удар) → DealDamageCircle (from step 2). Так не нужно плодить составные типы степов; «какой метод использует какой VFX» задаётся порядком и привязкой «from step index».

---

### 5.4 Влияние на противников (без прямого урона)

| # | Степ | Описание | Параметры | Длительность |
|----|------|----------|-----------|--------------|
| 15 | **AffectEnemiesDisplace** | Сместить цели (отброс/подтягивание). | Форма зоны (circle/rect), радиус/размер, offset, сила и направление смещения (от центра/от игрока). | 0%. |
| 16 | **AffectEnemiesRoot** | Временно заблокировать перемещение цели (root/snare). | Форма зоны, длительность бафа на цель (в сек или %). | 0%. |

Зоны можно задавать так же, как хитбоксы (circle/rect + from step index при желании).

---

### 5.5 Снаряды

| # | Степ | Описание | Параметры | Длительность |
|----|------|----------|-----------|--------------|
| 17 | **SpawnProjectile** | Создать снаряд, задать начальную скорость/направление. | Prefab снаряда, скорость (базовая), направление (facing / по вводу / по цели), опционально масштаб от статов (projectile speed stat). Логика масштабирования: baseSpeed * (1 + stat/100) или формула из баланса. | 0%. |
| 18 | **ProjectileOnHitEffect** | Наложить на уже созданный снаряд эффект при попадании (взрыв, AOE, дебафф). | Ссылка на «эффект при попадании» (отдельный маленький SO или enum: Explode, Pierce, etc.), параметры (радиус взрыва, урон множитель). **Привязка:** «применить к снаряду из степа N» (индекс предыдущего SpawnProjectile). | 0%. Рантайм запоминает последний заспавненный снаряд в этом касте и вешает на него компонент/обработчик. |

Так можно в одном скилле: степ 1 — SpawnProjectile, степ 2 — ProjectileOnHitEffect (target step 1) → фаербол с взрывом при попадании.

---

### 5.6 Специальные / служебные

| # | Степ | Описание | Параметры | Длительность |
|----|------|----------|-----------|--------------|
| 19 | **Wait** | Ничего не делать заданное время. | DurationPercent пайплайна (или фиксированные секунды). | N%. |
| 20 | **ChannelLoopStart** | Начало цикла ченнелинга (см. п. 4). | — | 0%. Семантика: следующий блок степов до ChannelLoopEnd повторять. |
| 21 | **ChannelLoopEnd** | Конец цикла ченнелинга. | Макс. длительность канала (сек), опционально tick rate. | 0%. |

Либо вместо отдельных степов ChannelLoopStart/End у скилла в данных явно: `IsChanneling = true`, `ChannelLoopSteps = [ список степов ]`, `ChannelMaxDuration`, `ChannelTickDuration`. Тогда в общем списке степов — только «обычные» шаги; ченнелинг обрабатывается рантаймом по флагу скилла. Так проще и не загромождает список степов.

---

### 5.7 Итоговая сводка по категориям

- **Персонаж:** CharacterDisplace, CharacterLaunch, CharacterBuff, MovementLock, MovementUnlock, CharacterPullDown, OptionalStepForward.
- **Оружие/анимация:** WeaponWindup, WeaponStrike, WeaponRecovery.
- **VFX/урон:** SpawnVFX, DealDamageCircle, DealDamageRectangle, SpawnVFXAndHitbox.
- **Противники:** AffectEnemiesDisplace, AffectEnemiesRoot.
- **Снаряды:** SpawnProjectile, ProjectileOnHitEffect.
- **Служебные:** Wait; ченнелинг — через флаг скилла и подсписок ChannelLoopSteps, без отдельных степов в общем списке.

Каждый тип степа — отдельная сущность (StepDefinitionSO или запись в базе) со своими дефолтами и полями; в скилле только ссылка на тип + оверрайды. Спрайты/иконки для редактора хранятся в определении степа.

---

## 5.8 Один момент — несколько действий (урон + смещение на 50% VFX)

**Задача:** один VFX кастуется один раз; в один и тот же момент (например 50% длительности VFX) должны произойти **несколько действий** (урон + смещение противников).

**Решение — отложенное срабатывание (Deferred Trigger):**

- У **StepEntry** есть опциональные поля: **TriggerAtStepIndex** (int), **TriggerAtPercent** (0–1).
- Если они заданы, степ **не выполняется в общем порядке**; он ставится в очередь на момент, когда степ с индексом `TriggerAtStepIndex` достигнет `TriggerAtPercent` своей длительности.
- Несколько степов могут иметь одинаковые `(TriggerAtStepIndex, TriggerAtPercent)` — в этот момент они **все выполняются** (рекомендуется запускать их **параллельно**).
- Пример: Step 0 = SpawnVFX (имеет длительность). Step 1 = DealDamageCircle (TriggerAtStepIndex=0, TriggerAtPercent=0.5). Step 2 = AffectEnemiesDisplace (TriggerAtStepIndex=0, TriggerAtPercent=0.5). Когда VFX степа 0 достигает 50%, рантайм запускает степы 1 и 2 одновременно.

Итог: один VFX, два (и больше) действия в один момент — через общую привязку к одному степу и одному проценту.

---

## 5.9 Параллельное выполнение (удар спереди и сзади, удар + бафф)

**Задача:** два или больше действий должны выполняться **одновременно** (не «в один момент по таймеру», а «старт в один и тот же кадр»): например два VFX (спереди и сзади), или удар + бафф на себя.

**Решение — степ типа ParallelGroup:**

- Новый тип степа **ParallelGroup**. Его «параметры» — список вложенных **StepEntry** (sub-steps).
- При выполнении ParallelGroup рантайм **одновременно** запускает все sub-steps (стартуют в один кадр). Если у подстепов есть длительность — ждём завершения **самого долгого**.
- В редакторе: один элемент списка «ParallelGroup», при раскрытии — вложенный список степов (те же типы и оверрайды). Порядок внутри группы для моментальных степов не важен; для степов с длительностью все идут параллельно.

Примеры:
- Два VFX: один степ ParallelGroup с двумя SpawnVFX (разные оверрайды: offset спереди / сзади, разные префабы при желании).
- Удар + бафф: ParallelGroup с DealDamageCircle + CharacterBuff.

---

## 6. VFX и «какой метод его использует»

- **Явная привязка:** в степах урона/хитбокса параметр **«Source step index»** (или «Copy from VFX step»): индекс степа в этом скилле, откуда брать позицию и масштаб. Обычно это предыдущий (или любой) степ SpawnVFX. Рантайм при выполнении DealDamageCircle/DealDamageRectangle смотрит в кэш «результаты степов» (например позиция и scale последнего VFX от степа с индексом N) и подставляет их в хитбокс.
- **Комбинированный степ SpawnVFXAndHitbox:** один степ сам держит и VFX, и момент удара (HitboxAtPercent), не нужна связь по индексу — всё внутри одного шага.
- Для дабл страйка: два раза подряд пары (SpawnVFX → DealDamageCircle from previous), без дублирования SO — только два элемента в списке степов скилла с разными оверрайдами (разные префабы VFX, разные множители урона при желании).

---

## 7. Редактор (без полного графа)

- **Окно/вкладка Skill Editor:** список степов выбранного скилла (таблица или вертикальный список). Для каждого степа:
  - выбор типа степа (dropdown по всем StepDefinitionSO);
  - отображение и редактирование только тех оверрайдов, которые есть у этого типа (префаб, радиус, %, ссылка на другой степ и т.д.);
  - иконка и название типа степа — из StepDefinitionSO.
- Перетаскивание для изменения порядка; добавление/удаление степов.
- **Переключатель RU/EN сверху:** названия типов степов в списке берутся из StepDefinitionSO. В каждом определении — **NameEn** и **NameRu** (только для отображения в редакторе, с именами файлов не связаны). Вверху редактора — переключатель «RU | EN»; в списке показывается выбранный язык.
- Опционально: общая длительность пайплайна (базовая) и превью суммы DurationPercent по степам.
- Отдельная секция для ченнелинг-скиллов: флаг IsChanneling, список ChannelLoopSteps, макс. время канала, длительность тика.

Так мы получаем понятную сборку скилла из степов без нодового графа, с одной сущностью на тип степа и без копирования этих сущностей под каждый скилл.

---

## 8. Порядок внедрения (кратко)

1. **Модель данных:** StepDefinitionSO (NameEn, NameRu, дефолты, иконка), StepEntry (type + overrides, опционально TriggerAtStepIndex/TriggerAtPercent, для ParallelGroup — sub-steps), SkillRecipeSO с списком степов, ChannelLoopSteps + IsChanneling.
2. **Рантайм:** SkillStepRunner: выполнение по списку; отложенные триггеры (при достижении % степа — запуск привязанных степов параллельно); ParallelGroup (параллельный запуск подстепов); прерывание (додж); ченнелинг-цикл.
3. **Реализация степов по приоритету:** MovementLock/Unlock, WeaponWindup/Strike/Recovery, SpawnVFX, DealDamageCircle (from step), DealDamageRectangle, остальные по необходимости.
4. **Додж:** отдельная механика + CancelCurrentSkill в рантайме скилла.
5. **Ченнелинг:** флаг и подсписок в скилле, цикл в рантайме.
6. **Редактор:** список степов, переключатель RU/EN для отображения названий типов, оверрайды по типу, поддержка ParallelGroup (вложенный список).
7. **Миграция:** текущий скилл Cleave перевести на рецепт (список степов), убедиться что поведение совпадает.
8. **Документация:** после реализации — отдельный документ «Документация по степам»: как использовать каждый тип степа, отложенные триггеры, параллельные группы, ченнелинг, примеры.
