# План реализации инвентаря в стиле Path of Exile

## Цели (из ТЗ)
1. **Перенос предметов и поиск плейсмента** — как в PoE (Swap-if-One, валидация области).
2. **Инвентарь и склад — отдельные окна**, оба могут быть открыты одновременно.
3. **Предмет в руке** — отдельная сущность: пока держит курсор, у предмета нет позиции в контейнере.
4. **Вкладки склада** — добавление/удаление вкладок.
5. **Без** аффинити, сетевой игры; экран 480×270, всё должно влезать.

---

## Этап 1: Модель данных — сетка (GridContainer)
- Класс **GridContainer**: 1D массив `InventoryItem[]` размером Cols×Rows.
- Один предмет N×M: во всех занятых ячейках одна и та же ссылка.
- Методы:
  - `GetItemAt(int index)` / `GetItemAt(int col, int row)` → предмет или null.
  - `GetRootAt(int index)` → корневой индекс (верх-лево) предмета в этой ячейке, или -1.
  - `CanPlace(InventoryItem item, int rootIndex)` — границы + все ячейки пустые или тот же item.
  - `Place(InventoryItem item, int rootIndex)` — удалить item из сетки (если был), записать в rect.
  - `Take(int rootIndex)` — убрать предмет по корню, вернуть ссылку.
  - `GetUniqueItemsInArea(int rootCol, int rootRow, int w, int h)` → HashSet<InventoryItem> для Swap-if-One.

## Этап 2: Состояния предмета
- **Stored** — в какой-то сетке (инвентарь или вкладка склада), позиция = root в этой сетке.
- **Carried** — предмет «в руке», не принадлежит ни одному контейнеру.
- Единый **CarriedItemHolder** (или в UI): хранит текущий переносимый предмет + источник (контейнер + root), чтобы при отмене/закрытии вернуть.

## Этап 3: Контейнеры
- **InventoryContainer**: одна сетка (рюкзак) + слот крафта + слоты экипировки (как сейчас, но логика через общую модель).
- **StashContainer**: список вкладок; каждая вкладка = один GridContainer (например 8×9 или 6×8 под 480×270).
- API контейнера: TryTake(containerId, rootIndex), TryPlace(containerId, rootIndex, item), CanPlace(containerId, rootIndex, item), GetUniqueItemsInArea(...).

## Этап 4: Алгоритм дропа (Swap-if-One)
1. По координатам мыши → контейнер + root (верх-лево под курсором с учётом размера предмета).
2. Если контейнер не под курсором — возврат в источник или поиск первого свободного.
3. `CanPlace(held, root)` → да: Place(held, root), очистить carried.
4. Иначе `GetUniqueItemsInArea(rect)` → если ровно 1 предмет: Take его → Place(held, root) → положить вытесненный в carried (следующий дроп) или в старый источник по правилам.
5. Если в области >1 разный предмет — блокировать, не ставить.

## Этап 5: Окна и UI
- **Окно инвентаря**: рюкзак + экипировка + крафт (текущая панель).
- **Окно склада**: вкладки + сетка текущей вкладки.
- Оба открыты одновременно — одна сцена UI; при переносе предмет «в руке» не в инвентаре и не в складе.
- Закрытие окна с предметом в руке: вернуть в источник или FindFirstEmpty в том же контейнере.

## Этап 6: Grab offset и призрак
- При OnBeginDrag: сохранить смещение курсора от верх-левого угла иконки (grabOffset).
- Иконка при перетаскивании: позиция = курсор - grabOffset.
- Ghost preview: по текущей позиции мыши вычислить целевой root; подсветить ячейки (зелёный — можно, жёлтый — своп, красный — нельзя).

## Этап 7: Вкладки склада
- Добавить вкладку (новая пустая сетка).
- Удалить вкладку (только если пустая).
- Переключение вкладки — смена активной сетки и перерисовка.

## Этап 8: Ctrl+Click
- При Ctrl+ЛКМ по предмету в контейнере A: взять предмет, FindFirstEmptySlot в контейнере B (другом открытом), Place туда; если нет места — оставить в A.

## Этап 9: Сохранение/загрузка
- Инвентарь: список предметов с root (SlotIndex = root для рюкзака, специальные индексы для крафта/экипировки).
- Склад: список вкладок, каждая — список предметов с SlotIndex (root в сетке вкладки).
- Формат ItemSaveData/StashTabSaveData оставить совместимым.

## Этап 10: Адаптация под 480×270
- Уменьшить размер слотов, отступы, шрифты так, чтобы инвентарь + склад помещались и оставались читаемыми.
- При необходимости сократить размер сетки (например рюкзак 8×4, склад 6×6 на вкладку).

---

## Порядок реализации
1. **GridContainer** (новая модель сетки с GetUniqueItemsInArea, Swap-if-One готовность).
2. **CarriedItemHolder** + интеграция: при драге — Take из контейнера, положить в holder; при дропе — Place/Swap, очистить holder.
3. **InventoryManager** переписать на GridContainer + слот крафта + экипировка; API для TryTake/TryPlace/CanPlace/GetUniqueInArea.
4. **StashManager** переписать: список GridContainer (вкладки), add/remove tab, тот же стиль API.
5. **InventoryUI**: два визуальных блока (инвентарь, склад), drag/drop с grab offset, ghost, Swap-if-One вызовы.
6. **Сохранение**: GetSaveData/LoadState из новых контейнеров.
7. **Ctrl+Click** и закрытие окна с предметом в руке.
8. **Подгонка под 480×270** (константы, USS).

После этого — тесты и полировка.

---

## Выполнено (первая итерация)

- **GridContainer** — единая сетка: GetItemAt, CanPlace, Place, Take, GetUniqueItemsInAreaAtRoot, FindFirstEmptyRoot.
- **InventoryManager** — рюкзак на GridContainer, Swap-if-One в PlaceItemAt (0 → место, 1 → своп, >1 → блок), слот крафта и экипировка без изменений, сейв/лоад по корням.
- **StashManager** — вкладки как List<GridContainer>, AddTab/ TryRemoveTab, Swap-if-One в PlaceItemInStash, GetUniqueItemsInStashArea, сейв/лоад.
- **InventoryUI** — grab offset при захвате (из рюкзака и склада): иконка не «прыгает» к центру курсора.
- Окна инвентаря и склада по-прежнему отдельные панели, оба могут быть открыты; предмет при перетаскивании не в контейнере (Take при drag start).

Остаётся: подсветка призрака (зелёный/жёлтый/красный), Ctrl+Click, закрытие с предметом в руке, подгонка под 480×270.
