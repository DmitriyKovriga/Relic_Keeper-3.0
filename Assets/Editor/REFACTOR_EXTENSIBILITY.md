# Расширяемость и точечный рефакторинг (без глобальных перестановок)

Места с теоретическими уязвимостями при развитии системы. Все предложения — локальные изменения в коде, без перестройки сцен/префабов в редакторе.

---

## 1. Эффекты крафт-орб (EffectId) — жёсткая привязка к строке

**Где:** `InventoryUI.cs` (проверка `EffectId != "reroll_rare"`), `ItemGenerator.RerollRare` вызывается напрямую.

**Риск:** Добавление новой орбы (chaos, alch и т.д.) потребует правок в нескольких местах и нового `if (EffectId == "chaos")` / вызова нового метода.

**Рефакторинг без перестройки:**
- Ввести **константы** в одном месте, например в `CraftingOrbSO` или отдельном статическом классе:
  - `public const string EffectRerollRare = "reroll_rare";`
- Заменить в коде все строковые литералы `"reroll_rare"` на эту константу.
- Дальше при появлении второго эффекта можно вынести диспетчер: по `EffectId` вызывать зарегистрированный обработчик (например, словарь `EffectId -> Action<InventoryItem>` или интерфейс `ICraftingOrbEffect`), чтобы не плодить `if/switch` в UI.

**Файлы:** `InventoryUI.cs`, `CraftingOrbSO.cs`, `CraftingOrbEditorWindow.cs`.

---

## 2. Имена слотов экипировки — дублирование с enum

**Где:** `InventoryUI.SetupEquipmentSlots()` — массив `string[] slotNames` и порядок должны совпадать с `EquipmentSlot` и с именами в UXML.

**Риск:** Добавление/переименование слота в enum потребует не забыть обновить массив и UXML; при рассинхроне — ошибки в рантайме.

**Рефакторинг без перестройки:**
- Завести **единый маппинг** порядок/имя: например статический метод или readonly-массив вида `(EquipmentSlot, string)[]` или словарь `EquipmentSlot -> UXML name` в одном месте (например в том же `InventoryUI` или в маленьком статическом классе).
- Имена слотов в UXML оставить как есть; в коде получать имя по `EquipmentSlot` из этого маппинга. Тогда добавление слота = одна новая строка в маппинге + один элемент в UXML, без правок в нескольких местах.

**Файлы:** `InventoryUI.cs`, при желании — общий хелпер (например `EquipmentSlotNames.cs`).

---

## 3. Индексы слотов навыков от слотов экипировки

**Где:** `PlayerSkillManager.GetSkillSlotByItemSlot(EquipmentSlot)` — switch с возвратом 0,1,2,3,4; **BodyArmor не обработан** (default → -1).

**Риск:** Если на тело когда-нибудь вешают скилл, он не получит слот; при добавлении новых слотов экипировки с навыками придётся править switch.

**Рефакторинг без перестройки:**
- Явно обработать `EquipmentSlot.BodyArmor` (решить, какой индекс скилла ему соответствовать, или -1 если скиллов на теле нет).
- Заменить switch на **массив или словарь** `EquipmentSlot -> int` (индекс скилл-слота), инициализируемый в одном месте. Добавление нового слота = одна запись в массиве/словаре.

**Файлы:** `PlayerSkillManager.cs`.

---

## 4. Пути Resources / AssetDatabase

**Где:** Разбросаны строки вида `Resources.Load<...>("CraftingOrbs/...")`, `AssetDatabase.LoadAssetAtPath<...>("Assets/...")`, пути к MenuLabels, Databases и т.д.

**Риск:** Перенос папок (например Localization, Resources) потребует поиска по проекту и правок во многих файлах.

**Рефакторинг без перестройки:**
- Собрать **все пути** в один статический класс или ScriptableObject с полями (например `ProjectPaths.cs` или `EditorPaths.asset`): пути к Resources, к папкам локализации, к базам. Остальной код обращается только к этим константам/полям.
- Редакторские пути — в одном месте (например общий класс для редактора), рантайм Resources — в другом. Сцену/префабы не трогаем.

**Файлы:** все, где есть `Resources.Load`, `LoadAssetAtPath` с хардкодом путей.

---

## 5. Версия формата сохранений

**Где:** `GameSaveData` и загрузка в `GameSaveManager` — нет поля версии.

**Риск:** При добавлении полей в сейв или смене семантики старые сейвы могут некорректно читаться или ломать игру.

**Рефакторинг без перестройки:**
- Добавить в `GameSaveData` поле `public int SaveVersion = 1;`.
- При сохранении — выставлять текущую версию (константа в одном месте).
- В начале `LoadGame()` читать версию и при необходимости вызывать **миграции** (отдельные методы типа `MigrateV1ToV2(GameSaveData data)`), после чего продолжать обычную загрузку. Новые форматы не трогают старые сейвы без миграции.

**Файлы:** `GameSaveData.cs`, `GameSaveManager.cs`.

---

## 6. Консистентность логов в ItemDatabaseSO

**Где:** `GetItem` и `GetAffix` при отсутствии элемента пишут предупреждение в лог; `GetSkill` — просто возвращает null без лога.

**Риск:** Отладка пропавших скиллов (например после переименования ассетов) сложнее.

**Рефакторинг без перестройки:**
- В `GetSkill` при отсутствии ID добавить опциональный вызов `Debug.LogWarning` по аналогии с `GetItem`/`GetAffix` (или завести общий параметр/флаг «логировать ли отсутствие»), чтобы поведение было единым. Никакой перестройки проекта не требуется.

**Файлы:** `ItemDatabaseSO.cs`.

---

## 7. Комментарии и магические числа в сейве

**Где:** `InventorySaveData.cs` — комментарий «Где лежит (включая экипировку > 100)»; в коде уже используются константы `EQUIP_OFFSET` и `CRAFT_SLOT_INDEX`.

**Риск:** Небольшой: кто-то может подумать, что 100 зашито в логику.

**Рефакторинг без перестройки:**
- В комментарии к `SlotIndex` указать: «индекс слота (см. InventoryManager.EQUIP_OFFSET / CRAFT_SLOT_INDEX)» или «значения >= EQUIP_OFFSET — экипировка». Так явно связываем контракт слотов с одним местом определения.

**Файлы:** `InventorySaveData.cs`.

---

## Приоритет внедрения (без перестройки)

| Приоритет | Что делать | Затраты |
|-----------|------------|---------|
| Высокий   | Версия сейва + миграции (п.5) | Мало, один раз закладывает фундамент |
| Высокий   | Константы для EffectId и замена "reroll_rare" (п.1) | Минимально |
| Средний   | Маппинг EquipmentSlot → имя слота UI (п.2) | Мало |
| Средний   | GetSkillSlotByItemSlot на массив/словарь + BodyArmor (п.3) | Мало |
| Низкий    | Централизация путей (п.4) | Средне, но точечно по файлам |
| Низкий    | Лог в GetSkill и комментарии сейва (п.6, п.7) | Минимально |

Все пункты можно внедрять по одному, без глобальных перестановок в редакторе.
